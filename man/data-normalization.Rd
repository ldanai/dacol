% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transformation.R
\name{data-normalization}
\alias{data-normalization}
\alias{transform_cosine}
\alias{transform_logistic}
\alias{transform_zscore}
\alias{dist_canberra}
\alias{dist_cosine}
\alias{dist_euclidean}
\alias{dist_pearson}
\alias{trim_outlier}
\alias{normalize_percentile}
\alias{get_confidence_interval}
\alias{decile_band}
\alias{decile_ptile}
\alias{mode_stats}
\title{Functions to normalize, transform, measure distance between numeric vectors}
\usage{
transform_cosine(x, max)

transform_logistic(x, max)

transform_zscore(x)

dist_canberra(x, y)

dist_cosine(x, y)

dist_euclidean(x, y)

dist_pearson(x, y)

trim_outlier(x, fraction = 0.01)

normalize_percentile(x, fraction = 0.01)

get_confidence_interval(x, level = 0.95)

decile_band(x, band_ptile = c(seq(0, 0.95, 0.05)))

decile_ptile(x, band_ptile = c(seq(0, 0.95, 0.05)))

mode_stats(x, na.rm = FALSE)
}
\arguments{
\item{x}{A numeric vector}

\item{max}{A numeric value}

\item{y}{A numeric vector}

\item{fraction}{The percentile value (0 to 0.5) to trim out}

\item{level}{The CI level (0.5 to 1.0) of observations to be measured.}
}
\value{
returns a numeric vector after normaliztion or distance between 2 vectors.
}
\description{
\code{transform_cosine} is the cosine transformation.
\code{transform_logistic} is the logistic transformation.
\code{transform_zscore} is the zscore transformation.
\code{dist_canberra} computes the Canberra distance between 2 numeric vectors.
\code{dist_cosine} computes the cosine angle distance between 2 numeric vectors.
\code{dist_euclidean} compute the Euclidience distance between 2 numeric vectors.
\code{dist_pearson} compute the Pearson correlation distance between 2 numeric vectors.
}
\details{
\code{decile_band} add columns with decile bands
\code{decile_ptile} add columns with decile percentiles
}
\examples{

library(tidyverse)

max = 30
dta1 = tibble(x1 = seq(-1.2*max, 1.2*max, length.out = 200),
              x2 = seq(0, max, length.out = 200),
              x3 = sample(200))

dta1 = mutate(dta1,

              # Transformation
              y_cosine   = transform_cosine(x1, max),
              y_logistic = transform_logistic(x2, max),
              y_zcore    = transform_zscore(x2),

              # Distant between 2 vector columns
              y_dist_canb = dist_canberra(x2, y_zcore),
              y_dist_cos  = dist_cosine(x2, y_zcore),
              y_dist_euc  = dist_euclidean(x2, y_zcore),
              y_dist_pear = dist_pearson(x2, y_zcore),

              # Manage outliers
              y_trim = trim_outlier(x3, 0.01),
              y_norm = normalize_percentile(x3, 0.01),

              # Stats measures
              y_mode = mode_stats(x3),

              # Band segmentation
              y_dec_band1 = decile_band(x3),
              y_dec_band2 = decile_band(x3, c(seq(0, 0.9, 0.1))),
              y_dec_ptile1 = decile_ptile(x3),
              y_dec_ptile2 = decile_ptile(x3, c(seq(0, 0.9, 0.1)))
              )
}
